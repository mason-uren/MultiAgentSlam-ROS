#include "JoystickGripperInterface.h"

#include <std_msgs/Float32.h> // For Gripper ROS messages

using namespace std;

// Default constructor so we can allocate space without providing parameters when needed
// For example declaring a variable of this type as a class member
JoystickGripperInterface::JoystickGripperInterface(){
    ready = false;
}

// Copy constructor
JoystickGripperInterface::JoystickGripperInterface(const JoystickGripperInterface& source){

    // Publisher state
    this->gripperWristAnglePublisher        = source.gripperWristAnglePublisher;
    this->gripperFingerAnglePublisher       = source.gripperFingerAnglePublisher;

    // Wrist state
    this->wristAngle                        = source.wristAngle;
    this->wristAngleChangeRate              = source.wristAngleChangeRate;
    this->wristAngleMax                     = source.wristAngleMax;
    this->wristAngleMin                     = source.wristAngleMin;
    this->wristJoystickVector               = source.wristJoystickVector;

    // Finger state
    this->fingerAngle                       = source.fingerAngle;
    this->fingerAngleChangeRate             = source.fingerAngleChangeRate;
    this->fingerAngleMax                    = source.fingerAngleMax;
    this->fingerAngleMin                    = source.fingerAngleMin;
    this->fingerJoystickVector              = source.fingerJoystickVector;

    this->nh                                = source.nh;
}

// The constructor needs a handle to the current ROS node and the name of the rover to control
// in order to setup the ROS command publishers.
JoystickGripperInterface::JoystickGripperInterface(ros::NodeHandle nh, string roverName){
    ready = false;

    this->nh = nh;

    // Initialize gripper angles in radians
    wristAngle = 0;
    fingerAngle = 0;

    // Setup angle change parameters - min and max are taken from the physical rover.
    // Should this be limited here or rely on the ROS command receivers to sensibly
    // handle commands that are out of bounds?
    wristAngleMin = 0.0;
    wristAngleMax = 1.0; // Rad

    fingerAngleMin = 0.0;
    fingerAngleMax = 2.0;

    // The fraction of the joystick output value by which to change the gripper angles
    // This should be tuned in accordance with user feedback.
    fingerAngleChangeRate = 0.1;
    wristAngleChangeRate = 0.1;

    // Representation of the desired movement speed and direction generated by the joystick
    fingerJoystickVector = 0.0;
    wristJoystickVector = 0.0;
    
    // Setup the gripper angle command publishers
    gripperWristAnglePublisher = nh.advertise<std_msgs::Float32>("/"+roverName+"/wristAngle/cmd", 10, this);
    gripperFingerAnglePublisher = nh.advertise<std_msgs::Float32>("/"+roverName+"/fingerAngle/cmd", 10, this);

    this->roverName = roverName;

    ready = true;
}

// Receives input from the joystick representing the direction and speed with which to move the wrist
// Records that desired motion and begins the command timer that cacluates and sends the movement commands
// to the appropriate ROS topics.
void JoystickGripperInterface::moveWrist(float vec) {
    if (!ready) throw JoystickGripperInterfaceNotReadyException();

    wristJoystickVector = -vec; // negate to make down the positive angle

    // Calculate the new wrist angle to request
    wristAngle += wristJoystickVector*wristAngleChangeRate;

    // Don't exceed the min and max angles
    if (wristAngle > wristAngleMax) wristAngle = wristAngleMax;
    else if (wristAngle < wristAngleMin) wristAngle = wristAngleMin;

    // If the wrist angle is small enough to use negative exponents set to zero
    // negative exponents confuse the downstream conversion to string
    if (fabs(wristAngle) < 0.001) wristAngle = 0.0f;

    std_msgs::Float32 angleMsg;
    angleMsg.data = wristAngle;
    gripperWristAnglePublisher.publish(angleMsg);

}


// Receives input from the joystick representing the direction and speed with which to move the fingers
// Records that desired motion and begins the command timer that cacluates and sends the movement commands
// to the appropriate ROS topics.
void JoystickGripperInterface::moveFingers(float vec){
    if (!ready) throw JoystickGripperInterfaceNotReadyException();

    fingerJoystickVector = vec;

    // Calculate the new wrist angle to request
    fingerAngle += fingerJoystickVector*fingerAngleChangeRate;

    // Don't exceed the min and max angles
    if (fingerAngle > fingerAngleMax) fingerAngle = fingerAngleMax;
    else if (fingerAngle < fingerAngleMin) fingerAngle = fingerAngleMin;

    // If the finger angle is small enough to use negative exponents set to zero
    // negative exponents confuse the downstream conversion to string
    if (fabs(fingerAngle) < 0.001) fingerAngle = 0.0f;

    // Publish the finger angle commands
    std_msgs::Float32 angleMsg;
    angleMsg.data = fingerAngle;
    gripperFingerAnglePublisher.publish(angleMsg);
}

void JoystickGripperInterface::changeRovers(string roverName)
{
   ready = false;

    gripperWristAnglePublisher.shutdown();
    gripperFingerAnglePublisher.shutdown();


    // Reset the gripper angles
    fingerAngle = 0;
    wristAngle = 0;

    // Reset joystick commands
    fingerJoystickVector = 0.0;
    wristJoystickVector = 0.0;

    this->roverName = roverName;

    // Setup the gripper angle command publishers
    gripperWristAnglePublisher = nh.advertise<std_msgs::Float32>("/"+roverName+"/wristAngle/cmd", 10, this);
    gripperFingerAnglePublisher = nh.advertise<std_msgs::Float32>("/"+roverName+"/fingerAngle/cmd", 10, this);
  ready = true;
}

// Clean up the publishers when this object is destroyed
JoystickGripperInterface::~JoystickGripperInterface(){
    ready = false;

    gripperWristAnglePublisher.shutdown();
    gripperFingerAnglePublisher.shutdown();
}
